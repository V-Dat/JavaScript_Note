{"documentTitle":"Asynchronous | Note","HeadingOne":"<a href=\"\">Asynchronous</a>","mainContent":"<h3>Content</h3>\n<details open>\n  <summary></summary>\n  <a href=\"#1\">1 - Asynchronous </a> <br>\n  <a href=\"#2\">2 -   </a> <br>\n  <a href=\"#3\">3 -  </a> <br>\n  <a href=\"#4\">4 -  </a> <br>\n  <a href=\"#5\">5 -  </a> <br>\n</details>\n\n\n<!-- =========================== 1 - Asynchronous =========================== -->\n\n<h3 id=\"1\"><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous\">1 - Asynchronous (*)</a></h3>\n\nIn JavaScript, Asynchronous used in two major contexts: <br>\n- <b class=\"red fs18\"> 1.1 Networking and communications: </b> <br>\n\nWhen software communicates asynchronously, a program may make a request for information from another piece of software (such as a server), and continue to do other things while waiting for a reply. For example, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX\">AJAX</a> (Asynchronous JavaScript and <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/XML\">XML</a>) programming technique—now usually \"Ajax\", even though <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/JSON\">JSON</a> is usually used rather than XML in modern applications—is a mechanism that requests relatively small amounts of data from the server using <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/HTTP\">HTTP</a>, with the result being returned when available rather than immediately. <br>\n\n\n- <b class=\"red fs18\"> 1.2 Software design : </b> <br>\nAsynchronous software design expands upon the concept by building code that allows a program to ask that a task be performed alongside the original task (or tasks), without stopping to wait for the task to complete. When the secondary task is completed, the original task is notified using an agreed-upon mechanism so that it knows the work is done, and that the result, if any, is available.<br>\n\n\n<!-- =========================== 2 -  =========================== -->\n\n<h3 id=\"2\">2 - Asynchronous in browser function </h3>\n\nMany functions provided by browsers, especially the most interesting ones, can potentially take a long time, and therefore, are asynchronous. For example: <br>\n\n- Making HTTP requests using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\" title=\"fetch()\">fetch()</a> <br>\n- Accessing a user's camera or microphone using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\" title=\"getUserMedia()\">getUserMedia()</a> <br>\n- Asking a user to select files using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker\" title=\"showOpenFilePicker()\">showOpenFilePicker()</a> <br>\n\n\n<!-- =========================== 3 - Blocking  =========================== -->\n\n<h3 id=\"3\">3 Blocking </h3>\n\n- Nếu chương trình được thực hiện theo mô hình Blocking có nghĩa là các dòng lệnh được thực hiện một cách tuần tự. Khi một dòng lệnh ở phía trước chưa được hoàn thành thì các dòng lệnh phía sau sẽ chưa được thực hiện và phải đợi khi mà thao tác phía trước hoàn tất, và nếu như các dòng lệnh trước là các thao tác cần nhiều thời gian xử lý như liên quan đến IO (input/output) hay mạng (networking) thì bản thân nó sẽ trở thành vật cản trở ( blocker ) cho các lệnh xử lý phía sau mặc dù theo logic thì có những việc ở phía sau ta có thể xử lý được luôn mà không cần phải đợi vì chúng không có liên quan gì đến nhau. <br>\n\n\n\n<!-- =========================== 4 - =========================== -->\n<hr>\n\n<img class=\"center\" src=\"https://vahid.blog/post/2021-03-21-understanding-the-javascript-runtime-environment-and-dom-nodes/jsRuntimeEnvironment_hufc6622042c18be00aa4535dddfa9305a_166610_1ca39972dbb2ec0390325362a63db04d.jpg\" >\n<h3 id=\"4\">4 -  </h3>\n","headingMainTwo":"<a href=\"\">Asynchronous Summary</a>","referanceContent":"<ol>\n <li><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript\">Javascript on Mozilla</a></li>\n <li><a href=\"https://stephengrider.github.io/JSPlaygrounds/\">Playgrounds</a></li>\n <li><a href=\"https://www.jsv9000.app/\">Javsacript Visualizer 9000</a></li>\n <li><a href=\"https://eloquentjavascript.net/\">Eloquent JavaScript - Mozilla Recommend Book</a></li>\n <li><a href=\"https://codersontrang.wordpress.com/2017/09/05/blocking-va-non-blocking-trong-lap-trinh/\">Blocking & Non-Blocking</a></li>\n <li><a href=\"https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/\">Callback - NodeJS</a></li>\n <li><a href=\"http://book.mixu.net/node/\">Mixu's Notebook</a></li>\n <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers\">Event Handling (MDN)</a></li>\n <li><a href=\"\"></a></li>\n\n</ol>\n ","dataTable":{"dataTableHeader":[{"data":"STT","name":"STT","actionSrc":"./Assets/Icons/plus-icon.svg","index":0,"bg":"hsl(148.82392100698883,50%,50%)"},{"data":"Method Name","name":"Method Name","actionSrc":"./Assets/Icons/plus-icon.svg","index":1,"bg":"hsl(148.82392100698883,50%,50%)"},{"data":"Syntax","name":"Syntax","actionSrc":"./Assets/Icons/plus-icon.svg","index":2,"bg":"hsl(148.82392100698883,50%,50%)"},{"data":"Involved","name":"Involved","actionSrc":"./Assets/Icons/plus-icon.svg","index":3,"bg":"hsl(148.82392100698883,50%,50%)"},{"data":"Description","name":"Description","actionSrc":"./Assets/Icons/plus-icon.svg","index":4,"bg":"hsl(148.82392100698883,50%,50%)"},{"data":"Action","name":"Action","actionSrc":null,"index":5,"bg":"hsl(148.82392100698883,50%,50%)"}],"dataTableFirstRow":[{"name":"stt","data":"0","index":0,"bg":""},{"name":"method","data":"<textarea></textarea>","index":1,"bg":""},{"name":"syntax","data":"<textarea></textarea>","index":2,"bg":""},{"name":"involved","data":"<textarea></textarea>","index":3,"bg":""},{"name":"description","data":"<textarea></textarea>","index":4,"bg":""},{"name":"action","data":null,"index":5,"bg":""}],"dataTableBody":[[{"data":1,"index":"0","name":"stt","show":["default-home"],"bg":""},{"data":"Blocking.","index":"1","name":"method","show":["home","detail"]},{"data":"Blocking.","index":"2","name":"syntax","show":["home","detail"],"bg":""},{"data":"Blocking.","index":"3","name":"involved","show":["home","detail"],"bg":""},{"data":"Blocking.","index":"4","name":"description","show":["home","detail"],"bg":""},{"data":null,"index":"5","name":"action","show":["default-home"]}],[{"data":2,"index":"0","name":"stt","show":["default-home"]},{"data":"Non-Blocking ","index":"1","name":"method","show":["home","detail"]},{"data":"Non-Blocking ","index":"2","name":"syntax","show":["home","detail"]},{"data":"Non-Blocking ","index":"3","name":"involved","show":["home","detail"]},{"data":"Non-Blocking ","index":"4","name":"description","show":["home","detail"]},{"data":null,"index":"5","name":"action","show":["default-home"]}],[{"data":3,"index":"0","name":"stt","show":["default-home"]},{"data":"Synchronous (Đồng bộ)","index":"1","name":"method","show":["home","detail"]},{"data":"Synchronous (Đồng bộ)","index":"2","name":"syntax","show":["home","detail"]},{"data":"Synchronous (Đồng bộ)","index":"3","name":"involved","show":["home","detail"]},{"data":"Synchronous (Đồng bộ)","index":"4","name":"description","show":["home","detail"]},{"data":null,"index":"5","name":"action","show":["default-home"]}],[{"data":4,"index":"0","name":"stt","show":["default-home"]},{"data":"ASynchronous (Bất Đồng bộ)","index":"1","name":"method","show":["home","detail"]},{"data":"ASynchronous (Bất Đồng bộ)","index":"2","name":"syntax","show":["home","detail"],"bg":""},{"data":"ASynchronous (Bất Đồng bộ)","index":"3","name":"involved","show":["home","detail"]},{"data":"ASynchronous (Bất Đồng bộ)","index":"4","name":"description","show":["home","detail"]},{"data":null,"index":"5","name":"action","show":["default-home"]},{"name":"note","data":"<!-- ============================================== 1 - Asynchronous ============================================== -->\n\n<b class=\"fs20 blue\"><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous\">1 - Asynchronous</a> </b> <br>\n","index":6,"show":["detail"]}],[{"data":5,"index":"0","name":"stt","show":["default-home"],"bg":"hsl(105.30853927157136,50%,50%)"},{"data":"Task Queue","index":"1","name":"method","show":["home","detail"],"bg":"hsl(105.30853927157136,50%,50%)"},{"data":"Task Queue","index":"2","name":"syntax","show":["home","detail"],"bg":"hsl(105.30853927157136,50%,50%)"},{"data":"Task Queue","index":"3","name":"involved","show":["home","detail"],"bg":"hsl(105.30853927157136,50%,50%)"},{"data":"Task Queue","index":"4","name":"description","show":["home","detail"],"bg":"hsl(105.30853927157136,50%,50%)"},{"data":null,"index":"5","name":"action","show":["default-home"],"bg":"hsl(105.30853927157136,50%,50%)"},{"name":"note","data":"<b class=\"red fs20\">Task Queue</b> <br>\n\n- Task Queue tương tự với CallStack <br>\n\n- Các hàm xử các tác vụ liên quan đến Bất đồng bộ sẽ được JavaScript đẩy qua xử lý ở Task Queue / Microtask Queue <br> <br>\n\n- Khi CallStack chống thì lúc này các Taskqueue sẽ được đẩy vào CallStack để thực thi \"Excute\" <br>\n\n- Taskqueue sẽ được đưa vào CallStack theo thứ tự, Taskqueue nào hoàn thành trước thì sẽ được đẩy vào CallStack để thực thi trước <br>\n\n<img src=\"./Assets/Async_Await/taskqueue.gif\" alt=\"microtask\" width=100% /> <br>\n\n<pre><code>//Example Taskqueue\nsetTimeout(function b() {}, 0);\n\nsetTimeout(function d() {\n  \n  setTimeout(function e() {\n    \n    setTimeout(function f() {}, 500);\n\n  }, 500);\n\n}, 1000);\n\nsetTimeout(function c() {}, 500);\n\nfunction a() {}\n\na();\na();\na();\na();\n</code></pre>\n \n\n<details><summary>Translate</summary>\n- The Task Queue is a FIFO queue of Tasks that are going to be executed by the Event Loop. Tasks are synchronous blocks of code that can enqueue other Tasks while they're running. <br>\n\n\n- If the Call Stack keeps track of the functions that are executing right now, then the Task Queue keeps track of functions that are going to be executed in the future. <br>\n\n- The Task Queue is a FIFO queue of Tasks that are processed by the Event Loop. Tasks are synchronous blocks of code. You can think of them as Function objects. <br>\n\n- The Event Loop works by continuously looping through the Task Queue and processing the Tasks it contains one by one. A single iteration of the Event Loop is called a tick. <br>\n\n- To process a Task, the Event Loop invokes the Function associated with it. While a Task is running, it has exclusive access to the Call Stack. The Event Loop waits to process the next Task until the current Task is finished, and the Call Stack is empty. <br>\n\n- While a Task is running, it can enqueue other Tasks to be processed in subsequent ticks of the Event Loop. There are several ways to do this, the simplest of which is setTimeout(taskFn, 0). Tasks can also come from external sources such as DOM and network events. <br>\n</details>","index":6,"show":["detail"]}],[{"data":6,"index":"0","name":"stt","show":["default-home"]},{"data":"Microtask Queue","index":"1","name":"method","show":["home","detail"]},{"data":"Microtask Queue","index":"2","name":"syntax","show":["home","detail"]},{"data":"Microtask Queue","index":"3","name":"involved","show":["home","detail"]},{"data":"Microtask Queue","index":"4","name":"description","show":["home","detail"]},{"data":null,"index":"5","name":"action","show":["default-home"]},{"name":"note","data":"<b class=\"red fs20\">Microtask Queue</b> <br>\n\n- Microtask Queue được thêm vào từ khi ES6 ra đời dùng để xử lý Promise, Microtask tương tự với Callstack <br>\n\n- Promise Handler sẽ được đẩy vào bên trong MicroTask xử lý thay vì đẩy vào CallStack <br>\n\n\n<img src=\"./Assets/Async_Await/microtask.gif\" alt=\"microtask\" width=100% /> <br>\n\n<pre><code>//Example MicroTask\nfetch('https://www.google.com')\n  .then(function a() {})\n  .then(function a() {})\n  .then(function a() {});\n  \nPromise.resolve()\n  .then(function b(){})\n  .then(setTimeout(()=>{console.log(\"3333\")},3000));\n\nPromise.reject()\n  .catch(function c() {});\n</code></pre>\n \n\n<details><summary>Translate</summary>\n- The Microtask Queue was added in ES6 to handle Promises. It's a lot like the Call Stack. The main difference is how Microtasks are enqueued and when they are processed. <br>\n\n- The Microtask Queue is a FIFO queue of Microtasks that are processed by the Event Loop. The Microtask Queue is very similar to the Task Queue. It was added to JavaScript's execution model as part of ES6 in -order to handle Promise resolution callbacks.<br>\n\n- Microtasks are a lot like Tasks. They are synchronous blocks of code (think of them as Function objects) that have exclusive access to the Call Stack while running. And just like Tasks, Microtasks are able to enqueue additional Microtasks or Tasks to be run next.<br>\n\n\n- The only difference between Microtasks and Tasks is where they are stored, and when they are processed.<br>\n- Tasks are stored in Task Queues. But Microtasks are stored in the Microtask Queue (there's only one of these).<br>\n- Tasks are processed in a loop, and rendering is performed in-between Tasks. But the Microtask Queue is emptied out after a Task completes, and before re-rendering occurs.<br>\n</details>","index":6,"show":["detail"]}],[{"data":7,"index":"0","name":"stt","show":["default-home"]},{"data":"Call Stack","index":"1","name":"method","show":["home","detail"],"bg":""},{"data":"Call Stack","index":"2","name":"syntax","show":["home","detail"],"bg":""},{"data":"Call Stack","index":"3","name":"involved","show":["home","detail"]},{"data":"Call Stack","index":"4","name":"description","show":["home","detail"]},{"data":null,"index":"5","name":"action","show":["default-home"]},{"name":"note","data":"<b class=\"red fs20\"><a href=\"https://262.ecma-international.org/9.0/#sec-execution-contexts\">Đặc tả Callstack </a></b> <br>\n\n\n- CallStack là một ngăn xếp Stack theo dõi việc gọi hàm của Javscript. <br>\n\n- Khi chương trình gọi một hàm (hàm này được xem là một stack), và stack đó được đẩy vào CallStack theo quy trình \"Vào cuối ra trước\" last-in-first-out (LIFO). <br>\n\n- Khi một hàm return thì Javascript sẽ đẩy stack đó ra khỏi CallStack <br>\n\n\n\n\n<img src=\"./Assets/Async_Await/callstack.gif\" alt=\"call-stack\" width=100%/> <br>\n\n<details><summary>Translate</summary>\n- The Call Stack tracks function calls. It is a LIFO stack of frames. Each frame represents a function call. <br>\n\n- The Call Stack is a fundamental part of the JavaScript language. It is a record-keeping structure that allows us to perform function calls. Each function call is represented as a frame on the Call Stack. This is how the JavaScript engine keeps track of which functions have been called and in what order. The JS engine uses this information to ensure execution picks back up in the right spot after a function returns. <br>\n\n- When a JavaScript program first starts executing, the Call Stack is empty. When the first function call is made, a new frame is pushed onto the top of the Call Stack. When that function returns, its frame is popped off of the Call Stack. <br>\n\n</details>\n\n\n\n<b class=\"red fs20\"><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Thread\">Thread</a></b> <br>\n\n- Thread trong khoa học máy tính là việc thực hiện nhiều tác vụ hoặc chương trình cùng một lúc. Mỗi đơn vị có khả năng thực thi mã được gọi là một luồng. <br>\n\n\n<details><summary>Translate</summary>\n- Thread in computer science is the execution of running multiple tasks or programs at the same time. Each unit capable of executing code is called a thread. <br>\n</details>\n\n\n\n<b class=\"red fs20\"><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Main_thread\">Main Thread</a> </b> <br>\n\n\n\n","index":6,"show":["detail"]}],[{"data":8,"index":"0","name":"stt","show":["default-home"],"bg":"hsl(290.7372981989459,50%,50%)"},{"data":"Event Loop","index":"1","name":"method","show":["home","detail"],"bg":"hsl(290.7372981989459,50%,50%)"},{"data":"Event Loop","index":"2","name":"syntax","show":["home","detail"],"bg":"hsl(290.7372981989459,50%,50%)"},{"data":"Event Loop","index":"3","name":"involved","show":["home","detail"],"bg":"hsl(290.7372981989459,50%,50%)"},{"data":"Event Loop","index":"4","name":"description","show":["home","detail"],"bg":"hsl(290.7372981989459,50%,50%)"},{"data":null,"index":"5","name":"action","show":["default-home"],"bg":"hsl(290.7372981989459,50%,50%)"},{"name":"note","data":"","index":6,"show":["detail"]}],[{"data":9,"index":"0","name":"stt","show":["default-home"],"bg":"hsl(180.21327627145456,50%,50%)"},{"data":"Event handlers\n","index":"1","name":"method","show":["home","detail"],"bg":"hsl(180.21327627145456,50%,50%)"},{"data":"Event handlers\n","index":"2","name":"syntax","show":["home","detail"],"bg":"hsl(180.21327627145456,50%,50%)"},{"data":"Event handlers\n","index":"3","name":"involved","show":["home","detail"],"bg":"hsl(180.21327627145456,50%,50%)"},{"data":"Event handlers\n","index":"4","name":"description","show":["home","detail"],"bg":"hsl(180.21327627145456,50%,50%)"},{"data":null,"index":"5","name":"action","show":["default-home"],"bg":"hsl(180.21327627145456,50%,50%)"},{"name":"note","data":"<b class=\"red fs20\">1. Event</b> <br>\n\n- An event, in a computing context, is an action or occurrence that can be identified by a program and has significance for system hardware or software. Events can be user-generated, such as keystrokes and mouse clicks, or system-generated, such as program loading, running out of memory and errors. <br>\n\n<b class=\"red fs20\">2. HTMLElement Event</b> <br>\n\n\n<b class=\"red fs20\">3. Event Listener </b> <br>\nEvent Listener là trình lắng nghe sự kiện <br>\n\n<b class=\"red fs20\">4. Event Handler </b> <br>\nEvent Handler là các hàm xử lý sự kiện <br>\n\n\n\n","index":6,"show":["detail"]}],[{"data":10,"index":"0","name":"stt","show":["default-home"],"bg":"hsl(301.8527880816144,50%,50%)"},{"data":"Callbacks\n","index":"1","name":"method","show":["home","detail"],"bg":"hsl(301.8527880816144,50%,50%)"},{"data":"Callbacks\n","index":"2","name":"syntax","show":["home","detail"],"bg":"hsl(301.8527880816144,50%,50%)"},{"data":"Callbacks\n","index":"3","name":"involved","show":["home","detail"],"bg":"hsl(301.8527880816144,50%,50%)"},{"data":"Callbacks\n","index":"4","name":"description","show":["home","detail"],"bg":"hsl(301.8527880816144,50%,50%)"},{"data":null,"index":"5","name":"action","show":["default-home"],"bg":""},{"name":"note","data":"<!-- ====================================== Callback function ====================================== -->\n<b class=\"blue fs20\">CallBack Function</b> <br>\n \n- Chúng ta có thuật ngữ <b class=\"blue\">CallBack</b> bởi vì Javascript là ngôn ngữ <b class=\"blue\">First Class Function. </b> <br>\n\n- <b class=\"blue\">Callback</b> thật chất là một hàm được truyền vào bên trong hàm khác thông qua đối số, <b class=\"blue\">Callback</b> sẽ được thực hiện bên trong hàm đó. <br> \n\n- Chính vì sự đặc biệt đó nên nó được người ta đặt cho một cái tên là <b class=\"blue\">Callback</b> để phân biệt với những hàm khác <br>\n\n- <b class=\"blue\">Callback</b> còn được chia thành <b class=\"red\">Synchronous Callback </b> và <b class=\"blue\"> Asynchronous Callback </b> <br>\n\n<details><summary><b class=\"blue\">FIRST CLASS FUNCTION</b> </summary>\n\n- Javascript là ngôn ngữ First Class Functions hay First Class Citizens, Nghĩa là nó có những khả năng sau đây: <br>\n\n1) function được sử dụng như một value, có thể gán vào biến <br>\n2) function có thể truyền vào một function khác thông qua đối số <br>\n3) function có thể thực thi bên trong function khác <br>\n4) function có thể được trả về bằng từ khóa return <br>\n</details>\n\n\n<details><summary>ENG</summary>\n\n- We have the terms <b class=\"blue\">Callback</b> Function because Javascript is First Class Function, so we can pass a function into another function. <br>\n\n- A <b class=\"blue\">Callback</b> function is a function which is passed into another function as an argument, abd it will be invoked sometime later inside the outer function <br>\n\n- First Class Functions -> The ability to to use functions as values and which can be passed as arguments to another function, and also can be returned from functions. <br>\n- First class Functions / first class citizens :  <br>\n1) used as values <br>\n2) can be passed as argument <br>\n3) can be executed inside a closured function <br>\n4) can be taken as return <br>\n</details>\n\n\n<pre class=\"js\"><code class=\"javascript\">// Example\nsetTimeout(callbackFn, time);\n\nfunction wakeMeUp(){\n   Making noisy sound to wake up\n}\n\nsetTimeout( wakeMeUp , 5Hours ) \n\n- After 5 Hours execute function wakeMeUp => Make a noisy sound\n</code></pre>\n\n\n<b class=\"red fs22\">1 - Asynchronous Callback : </b> <br> \n\n- Note, however, that <b class=\"blue\">Callback</b>  are often used to continue code execution after an <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous\">asynchronous</a> operation has completed — these are called asynchronous callbacks. A good example is the <b class=\"blue\">Callback</b>  functions executed inside a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\">.then()</a> block chained onto the end of a promise after that promise fulfills or rejects. This structure is used in many modern web APIs, such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\">fetch()</a>. <br> <br>\n\n- <b class=\"blue\">Callback</b> thường được sử dụng để tiếp tục thực thi code sau khi một hoạt động bất đồng bộ được hoàn thành => <b class=\"blue\">Callback</b>  được gọi là Asynchronous Callback <br> <br>\n\n\n<b class=\"red fs22\">2 - Synchrnous Callback :</b> <br>\n\n- Ngoài Asynchronous Callback chúng ta còn có Synchronous Callback.  \n- Synchronous Callback thường được ứng dụng để \n-\n-\n- Example Synchronous Callback <br>\n\n<pre><code class=\"javascript\">function calculate(num1, num2, callbackFunction) {\n    return callbackFunction(num1, num2);\n}\n\nfunction calcProduct(num1, num2) {\n    return num1 * num2;\n}\n\nfunction calcSum(num1, num2) {\n    return num1 + num2;\n}\n// alerts 75, the product of 5 and 15\nalert(calculate(5, 15, calcProduct));\n// alerts 20, the sum of 5 and 15\nalert(calculate(5, 15, calcSum));\n</code></pre>\n\n","index":6,"show":["detail"]}],[{"data":11,"index":"0","name":"stt","show":["default-home"]},{"data":"Promise","index":"1","name":"method","show":["home","detail"],"bg":""},{"data":"Promise <br>\n\n<ul>\n  <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise()</a></li>\n  <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\">Using promises</a></li>\n  <li><a href=\"https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html\" class=\"external\" rel=\" noopener\">We have a problem with promises</a> by Nolan Lawson</li>\n  <li><a href=\"https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/\" class=\"external\" rel=\" noopener\">Let's talk about how to talk about promises</a></li>\n</ul>\n","index":"2","name":"syntax","show":["home","detail"],"bg":""},{"data":"Promise <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#using_the_fetch_api\">Using the fetch() API</a>  <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#chaining_promises\">Chaining promises</a>  <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#catching_errors\">Catching errors</a>  <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#promise_terminology\">Promise terminology</a>  <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#combining_multiple_promises\">Combining multiple promises</a> \n <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await\" aria-current=\"true\">async and await</a>  <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#conclusion\">Conclusion</a>  <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#see_also\">See also</a>  <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#in_this_module\">In this module</a> <br>\n","index":"3","name":"involved","show":["home","detail"],"bg":""},{"data":"Promise","index":"4","name":"description","show":["home","detail"],"bg":""},{"data":null,"index":"5","name":"action","show":["default-home"]},{"name":"note","data":"<!-- ======================================= Promise ======================================= -->\n<b class=\"fs22 blue\">Promise</b> <br>\n- Để giải quyết các vấn đề bất đồng bộ JavaScript đơn giản chúng ta có thể sử dụng <b class=\"blue\">CallBack</b>, Tuy nhiên khi có nhiều tác vụ bất đồng bộ phải lồng vào nhau dẫn đến hiện tượng <b class=\"red\">CallBack Hell</b>. Vì vậy từ ES6 chúng ta đã có thêm khái niệm là <b class=\"blue\">Promise</b> <br>\n\n- Promise object đại diện cho việc hoàn thành kết quả (hoặc sự thất bại) từ của một hoạt động bất đồng bộ, và giá trị kết quả của lệnh đó. <br>  \n\n- Mục đích của Promise là cơ chế của nó giúp bạn thực hiện các tác vụ đồng bộ hơn và tránh rơi vào tình trạng callback hell hay pyramid of doom, là tình trạng dùng các callback lồng nhau quá nhiều <br> \n\n- Promise được trả về từ các API như fetch  <br>\n\n<b class=\"fs22 blue\">Promise State</b><br>\nPromise có 3 trạng thái : <br>\n- pending: trạn thái ban đầu, không thành công cũng không thất bại <br>\n- fulfilled: trạng thái thành công.<br>\n- rejected: trạng thái thất bại.<br>\n\n<!-- ======================================= Promise Code Example ======================================= -->\n\n<pre class=\"js\"><code>// Example About Promise \nconst alarmPromise = function(time){\n    return new Promise((resolve) => {\n        setTimeout(() => {resolve(\"Promise: Ring ring ring\")} ,time)\n    })\n}\n\nalarmPromise(5000).then(res => {\n    console.log(res)\n});\n\n// Example About Callback\nconst alarmCB = function(time,cb){\n    setTimeout(() => cb(\"CallBack: ring ring ring\"),time)\n}\n\nalarmCB(8000,(data)=>{console.log(data)})\n</code></pre> <br>\n<!-- ======================================= Compare Promise And CallBack ======================================= -->\n\n<b class=\"fs22 blue\">Promise And CallBack</b><br>\n\n- Kết quả thu được từ <b class=\"red\">CallBack</b> và <b class=\"blue\">Promise</b> đều như nhau. <br>\n\n- Về mặt cú pháp thì có vẻ như <b class=\"red\">CallBack</b> sẽ dễ hơn <b class=\"blue\">Promise</b>, Tuy nhiên <b class=\"blue\">Promise</b> sẽ giải quyết được vấn đề <b class=\"red\">CallBack Hell</b> <br>\n\n- Đối với <b class=\"red\">CallBack</b> thì việc định nghĩa sẽ khó hơn một chút tuy nhiên khi sử dụng lại dễ hơn. Chỉ cần gọi hàm sau đó truyền <b class=\"red\">CallBack</b> vào bên trong phương thức then  <br>\n\n\n<!-- ======================================= English - Promise ======================================= -->\n\n<details><summary>ENG - PROMISE</summary>\n\n<b class=\"fs22 blue\">Promise</b> <br>\nThe Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.<br>\n\n<b class=\"fs22 blue\">Promise State</b><br>\n\nA Promise is in one of these states:<br>\n\n- pending: initial state, neither fulfilled nor rejected.<br>\n- fulfilled: meaning that the operation was completed successfully.<br>\n- rejected: meaning that the operation failed.<br>\n\n\n</details>\n\n","index":6,"show":["detail"]}],[{"data":12,"index":"0","name":"stt","show":["default-home"]},{"data":"<b class=\"blue fs20\">Async - Await</b>","index":"1","name":"method","show":["home","detail"],"bg":""},{"data":"<b class=\"blue fs20\">Async - Await</b>","index":"2","name":"syntax","show":["home","detail"],"bg":""},{"data":"<b class=\"blue fs20\">Async - Await</b>","index":"3","name":"involved","show":["home","detail"],"bg":""},{"data":"<b class=\"blue fs20\">Async - Await</b>","index":"4","name":"description","show":["home","detail"],"bg":""},{"data":null,"index":"5","name":"action","show":["default-home"]},{"name":"note","data":"<b class=\"blue fs20\">Async - Await</b><br> \n<pre class=\"js\"><code>// Example Async - Await\n\nfunction delay(time){\n   return new Promise(resolve => \n       setTimeout(()=>{\n           console.log(\"Ring ring ring\");\n           resolve();\n       },time))\n}\nasync function alarmAsyn(time){\n    await delay(time);\n    console.log(\"I'm trying to sleep\");\n}\n\nalarmAsyn(5000).then( ()=> {\nconsole.log(\"I wake up and turn of alarm\")})\n\n</code></pre>","index":6,"show":["detail"]}]]}}